//
//	Package - transpiled by c4go
//
//	If you have found any issues, please raise an issue at:
//	https://github.com/Konstantin8105/c4go/
//

package code_quality

import "reflect"
import "runtime"
import "unsafe"

// sstr_s - transpiled function from  C4GO/tests/code_quality/function.c:1
var sstr_s []byte

// sstr_bufs - transpiled function from  C4GO/tests/code_quality/function.c:2
var sstr_bufs []byte = make([]byte, 10)

// sstr_n - transpiled function from  C4GO/tests/code_quality/function.c:3
var sstr_n int32

// sstr_pop - transpiled function from  C4GO/tests/code_quality/function.c:5
func sstr_pop() []byte {
	var ret []byte = sstr_s
	sstr_s = sstr_bufs[func() int32 {
		sstr_n--
		return sstr_n
	}():]
	return ret
}

// sstr_next - transpiled function from  C4GO/tests/code_quality/function.c:12
func sstr_next() int32 {
	return func() int32 {
		if int32(sstr_s[0]) != 0 {
			return int32(uint8((func() []byte {
				defer func() {
					sstr_s = sstr_s[0+1:]
				}()
				return sstr_s
			}())[0]))
		}
		return -1
	}()
}

// sstr_back - transpiled function from  C4GO/tests/code_quality/function.c:17
func sstr_back(c int32) {
	sstr_s = c4goPointerArithByteSlice(sstr_s, int(-1))
}

// c4goPointerArithByteSlice - function of pointer arithmetic. generated by c4go
func c4goPointerArithByteSlice(slice []byte, position int) []byte {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[]byte)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}
